# Day17
完善的修改版本方式。

## rebase
上次提到的rebase，只是它的功能一小部分，範例是將特定版本建立到現在版本下。而今天要提的是`git rebase -i [commitID]`的用法。

![](https://i.imgur.com/g5sPC5K.png)

這是`git rebase -i`下面給的訊息，它裡面有10種多的字母選項。而今天要提的是前面幾個關於編輯版本上的動作，有p,r,e,s,f,d。至於其他應用上的東西，之後有遇到再來研究。

## 查看動作
用`git rebase -i`後會跳出一些內容跟訊息，訊息在上方可以看到，現在要提的是內容部分。

![](https://i.imgur.com/7iLyBIw.png)

可以看到，目前狀況是這樣，先後順序依序是上到下，它會逐行執行動作，pick就是放入這個commit的意思，所以這裡順序是 "add b.txt" > "add c.txt" > "a.txt is 2"。

## 調換順序
調換順序是最簡單的，不用改變任何內容，只要改變pick的順序就可以。

![](https://i.imgur.com/zpzbHrc.png)

像附圖，就是讓b.txt跟c.txt的建立版本調換過來，當然可以調換很多甚至全部順序重新排列都可以。

![](https://i.imgur.com/kV3hZWm.png)

如圖，就是完成後的樣子。

### 衝突發生
我覺得全部之中，最容易發生衝突的就是這裡了。因為版本修改內容都是固定的，尤其是做一個大修改時，每個版本都有關於某些版本的東西，這就很容易出問題。而解決方式其實很簡單但也很累，就是一個個版本去修正它。舉個例子，下圖左邊是原始樣子，右邊是完成後的樣子。

![](https://i.imgur.com/dzEtatA.png)

看起來很簡單的只是將兩個版本對調而已，但其中我做了3次修正。

- "a.txt is 4"
  - 因為他認為這次修改是"5變成4"，但現在要換成"3變成4"叫你修改
- "a.txt is 5"
  - 因為他認為這次修改是"3變成5"，但現在要換成"4變成5"叫你修改
- "a.txt is 2 cherry-pick"
  - 因為他認為這次修改是"4變成2"，但現在要換成"5變成2"叫你修改

這很明確的可以看出來，因為修改同一個地方，所以發生衝突，雖然你很想表示，乾脆這樣就好，但是最後還是一個個修改的好。這裡要注意，如果對merge關係不熟的可能會發生問題。衝突的內容會長這樣。

![](https://i.imgur.com/rTRbOEA.png)

HEAD是只被修改版本的前一個版本，因為HEAD移動到它後，發現後面有問題。所以如果要維持改版狀態，要將內容改成下面的內容，而如果覺得下面改版是多餘或是不必要的，就改成上面的內容。

假如我上面三個衝突時，想到a.txt同一個部分會一直被修改，我可以在第一次修改時保留3而非更新到4。這樣第二次衝突就不會發生，因為內容跟git預期一樣是"3變成5"。

## 修改commit文字
這時候就將你要改名稱的那個版本，pick改成reword，存檔關掉後，它便會跳到那個版本的文字內容給你編輯。

## 修改版本
pick改成edit便可以修改版本，而在修改版本這裡可以做很多我們認為不一樣的修改方式。

1. 新增版本：當你停在這後，只要新增內容`git commit`就能夠在這插入一個版本。
2. 修改版本：用`git commit --ament`就能對此版本增加修改。
3. 分解版本：只要remove你覺得要在下個版本修改的部分，然後`git commit --amend`，之後在`git commit`新增一個版本，就能將一個版本分成兩個了。

## 壓縮版本
說壓縮是因為跟merge有些不同，因為是在同一條線上執行，也沒有先後順序問題。但這裡壓縮版本有兩種狀況，一是保留後者版本資訊，二是刪除後者版本資訊，這裡用squash跟fixup來分別。

狀況是，假設版本是A>B>C，你現在想讓B,C合併，你會`git rebase -i A`，而此時狀況會是。

```
pick B
pick C
```

你要壓縮它們是對後者做修改，所以會是：

```
pick B
squash C
```

用了後結果會是 A>BC，BC原因是B是B版本的message而C是C的，所以保留所有訊息內容。而用fixup就會是保留B而變成A>B的樣子。

## 絕對名稱
要注意，這裡做完rebase後，在被修改的版本後的所有版本絕對名稱都會改變。

![](https://i.imgur.com/zLJCvwO.png)

例子如下第一次修改是將"add b.txt"跟"add c.txt"調換，而沒被變動的"a.txt is 2"卻也改了，是因為它在它們後方。而第二次修改"a.txt is 2"跟"add c.txt"就可以看到，"add b.txt"的名稱沒有改變，是因為它在修改前方。

## 感想
今天練習了很多rebase的用法，但其實rebase看來還有很多用途，實在是太神奇了。