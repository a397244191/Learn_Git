# Day12
修改commit

## 好的版本控管
雖然當東西大到一個地步時，版本可能會有數千個，而這些版本連自己都不會想一一查閱，但當出現bug時，要如何尋找bug起源並追蹤它，這些版本紀錄就是一個很重要的依據。

### 養成習慣
為了萬一發生需求時能夠有所幫助，平時在做版本時就要有所根據，已下是文中提到的三個基本要求。

- 每個版本都
  - 凡走過必留下痕跡，這樣更可以幫助我們追蹤版本跟鎖定bug出處。
- 不要一大陀修改再做版本
  - 跟上一個原因一樣，當你終於知道bug是在這版本產生時，卻發現這裡面被改動了數千行，你根本無從找起bug。
- 有邏輯及相關的順序commit
  - 這是為了連接上下commit有邏輯相關性，以方便追蹤時能有邏輯依據。

### 結論
不過畢竟是人，何況是有很多人一起做事，誰能確保版本提交完全沒問題呢?所以才需要接下來的版本修改及刪除。

## 修正歷史紀錄
到目前學的東西，都是local端的管理方式，畢竟跟遠端做控管又是更麻煩的事情了。

### 理由
而我們為何要修正歷史紀錄呢?如果一份紀錄被很多人管理，哪是一個人能夠說改就改的呢?所以有些狀況下，我們會做到修改版本的事。

假設當前版本狀況為：Ａ＞Ｂ＞Ｃ

1. C是錯誤的commit或是拿來測試沒動到內容，需要刪除
2. commit message有錯字，需要改字，但不會動到內容
3. C按邏輯應該比B更早commit，想修正成Ａ＞Ｃ＞Ｂ
4. B少加了一個重大的東西就被commit了，想補救
5. 在你「分享」前發現有瑕疵，需要修改後再分享

### 注意事項
git有保留修改的原因，主要是在使用者可以在「自我控管」到一定程度後，再整理好資訊，好讓「發佈」後，別人可以經由這些對你的東西了解。

所以有些需要特別注意的地方。

- 一個儲存庫可以有許多分支
  - 預設為 master。
- 分享原始碼的最小單位是以「分支」為單位
  - 沒人會想管你每次小修改做的事情。
- 你可以任意修改某個支線上的版本，只要你還沒「分享」給其他人
  - 「分享」前，沒人會看到，不會擾亂別人。
- 當你「分享」特定分支給其他人之後，這些「已分享」的版本歷史紀錄就別再改了！
  - 「分享」後再去修改只會造成風波和混亂，不會變好。


## 練習管理
這次為了能簡單看到狀態，所以新開了一個git_commit的資料夾。

### 創建初始的log
最開始先替空殼補上三次commit，分別是初始化(a.txt存在)、修改a.txt 和新增b.txt。

![](https://i.imgur.com/q6mJz5Z.png)

### 刪除
我們可以利用`git reset --hard "HEAD^"`，來將儲存狀態回到上一個版本，也就等同於刪除最新的版本。

而這裡因為`^`的保留字，除了之前提到的`^^`以外，將那段用`""`包起來也是一種解決法。

![](https://i.imgur.com/YXzQAfg.png)

這可以看到，我們下完指令後`git log`只剩下兩個紀錄。而其實被刪除的commit還是被當物件存在`.git\objects`裡，所以後面`git show`還是可以查看紀錄。

而如果要回復刪除的部分，就用`git reset --hard ORIG_HEAD`就可以回到該branch最新的版本。

### 保留變更刪除
我們用`git reset --soft "HEAD^"`就能保留原本變更刪除。而有所不同的是，我們原本最新的commit狀態被保留下來成未commit前，可以用`git status`來查看。

![](https://i.imgur.com/pNVZgMd.png)

圖可見雖然`git log`看到的版本是前一個。可是b.txt在soft reset後還是存在，並且已被追蹤加入索引，所以status看到是綠色的。

### 重新提交
我們如果要修改當前commit就用`git commit --amend`就能夠修改當前commit。

![](https://i.imgur.com/jDBk5f7.png)

而當你輸入後，會跳出修改畫面，會像圖上一樣，成現最後一次commit的內容。

![](https://i.imgur.com/43eaUdj.png)

以上是用`git commit --amend`來最修改並新增c.txt的部分。可以看出，commit的絕對名稱從e44c變成了783d，因為修改到了內容，所以物件的絕對名稱也變了。

## 感想
看完這部分說的後，我想我這類似日誌的內容一直push到git跟這內容的方針有所出入，不過為了養成git習慣跟練習這也是必須的，所以今天有想考慮從目前學到的方式來管理一份git看看。